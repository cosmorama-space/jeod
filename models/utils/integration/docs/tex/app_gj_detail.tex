\section{Terminology}
\subsection{Priming Points}
The Gauss-Jackson algorithm relies on knowledge of the history of the
derivatives. In order to generate that early in the simulation,
priming points must be identified. This history is stored in the
Gauss-Jackson integrator structure as \textit{deriv\_hist} and referred to as
``back points'' in this document. More specifically, ``priming
points'' are those back points generated by another integrator (we use RK4)
in order to generate the initial history that the Gauss-Jackson integrator
needs before it can be started. 

There is potential for some confusion here; in the code,
``back-points'' are exclusively the
pre-epoch priming points, i.e., those priming points that precede the
starting point (the integration starts by going in reverse for a
short time).

\subsection{Bootstrapping the RK4 timestep}
As discussed in the \textref{Conceptual 
Design}{sec:concept_design_gj_bootstrap} section, this is a multi-cycle 
integrator.  Thus, there are two
time-steps, a \textit{cycle-time}, and a \textit{tour-time}. The cycle-time is 
referred to in the code as the \textit{cycle} time, and the tour time as the 
\textit{integ} time.  Both concepts have an associated \textit{simdt} and
\textit{dyndt}, representing the simulation counter-clock, and real
elapsed-time respectively.

\subsection{Two-state Integrator}
As discussed in the \textref{Conceptual 
Design}{sec:concept_design_gj_dimension} section, 
this algorithm integrates the
first-order differential equation for velocity, and the second-order
differential equation for position; it is not a two-state
integrator in the same sense as the other JEOD integrators. 
To fit into the same
architecture as the other integrators, it takes the same inputs as a two-state
integrator with one significant difference: when a two-state integrator
is called, it requires four inputs -- zeroth-derivative of state and
its derivative, along with the first-derivative state and its
derivative. This algorithm requires only three of these, since the
derivative of the zeroth-derivative state is equivalent to the
first-derivative state. Once in the algorithm, the input values
are assigned to the internal variables \textit{state},
\textit{state\_dot}, and \textit{state\_dotdot.}

\subsection{Class Overview}
As with the other integrators, this model includes a state integrator 
(\textit{GaussJacksonTwoStateIntegrator}), time integrator 
(\textit{GaussJacksonTimeIntegrator}), and integrator constructor 
(\textit{GaussJacksonIntegratorConstructor}).  In addition, because this is a 
multi-cycle integrator, we also need to implement an integrator-specific 
controls class, \textit{GaussJacksonIntegrationControls}.  
 
The presentation of the methods involved in the algorithm focuses on the two 
main classes:
\begin{itemize}
 \item \textit{GaussJacksonIntegrationControls} (referred to as simply the
\textit{integration controls})
\item \textit{GaussJacksonTwoStateIntegrator} (referred to as the
\textit{integrator}).
\end{itemize}


Recall from the basic conceptual design discussions (see \reftext{Conceptual Design}{sec:con_des_integ_group} that each Integration Group (which
must, by definition, have only one integration type) has its own time
integrator and controls, and one or more integrators.

The integrator handles the integration of any
single state, while the integration controls handles all the common
data between different members of a group of integrators, and ensures
that the integrators stay together in time, determining the time-step
for all integrators in the group, and giving permission for all
integrators to advance only when the states have converged for all
integrators in the group.

The methods in the constructor are generic, those in the time integrator are 
specific but trivial (advance time by one
increment at the appropriate phase); the integration controls are
generally straightforward and most do not require additional
explanatory documentation, although a brief logic flow description is
included in the \reftext{Detailed Design}{sec:GJ_Detailed_Design_Controls}.
The logic flow in the integrator is more convoluted and is described more 
thoroughly in the
\reftext{Detailed Design}{sec:GJ_Detailed_Design_Integrator}.


\section{Design Details and Methods}
\subsection{Integration Controls}\label{sec:GJ_Detailed_Design_Controls}

\subsubsection{integrate}
The main call to integrate is to the generic
\textit{IntegrationControls::integrate} method. Here, the following
steps are followed:

\begin{enumerate}
\item The \textit{step\_number} variable is incremented; it counts the number of
visits in an integration tour.
\item For the first integration cycle in a tour, the model-specific
\reftext{start\_integration\_tour}{ref:GJ_start_integration_tour} 
method is called
\item The \textit{target\_stage} is set (this identifies the point
within an integration cycle that should be reached by calling the
integrators).
\item All of the integrators for the group are called.
\item If all integrators reach their \textit{target\_stage }(e.g. during
the correction phase, if all integrators have a state that has
converged), then the time integrator for the group is called, and the
cycle stage is set to the target.
\item If the cycle-stage (having been just updated) represents the end
of the cycle, and the integration is identified as needing multiple
cycles per tour, the model-specific method
\reftext{end\_integration\_cycle}{ref:GJ_end_integration_cycle} is called.
\end{enumerate}

\subsubsection{start\_integration\_tour}\label{ref:GJ_start_integration_tour}

At the start of the simulation, this first calls the method
\textit{initialize}, which in turn sets some initial data, allocates
some memory, and calls the method 
\reftext{generate\_cycle\_step\_size}{ref:GJ_generate_cycle_step_size}.
This is the only access to
the \textit{generate\_cycle\_step\_size} method. The integration
controls also keeps account of the time at the end of the current tour
step and cycle step.

\subsubsection{generate\_cycle\_step\_size}\label{ref:GJ_generate_cycle_step_size}

When a simulation starts, the priming points must be determined using a
RK4 integrator. The maximum size of the time-step that the RK4
integrator can safely use can be assigned by the user. Where this
value is assigned, and is smaller than the requested integration
step-size, the whole integration tour step must be divided into
multiple cycle steps. This algorithm keeps halving the step size
until it is smaller than the maximum allowable step size for RK4.
NOTE -- if this value is not assigned, then the cycle step and the
tour step will be made equal.

\subsubsection{construct\_coefficient\_arrays}

This method follows the development presented in the \reftext{Mathematical
Formulations section}{sec:math_form_gj_coeffs}
in deriving the integration coefficients for a
given order.


\subsubsection{end\_integration\_cycle}\label{ref:GJ_end_integration_cycle}

At the end of an integration cycle, a new state has been generated.
NOTE -- it may not be the desired state, that comes at the end of an
integration tour (which always coincides with the end of an integration
cycle).  The integration starts in reverse, generating the pre-epoch
priming points. For as long as these are being generated, the
integration must be multi-cycle, because it is generating points that
cannot be at the tour-end-time. Once the priming shifts to generating
the post-epoch priming points, then the integration will only be
multi-cycle if the cycle time and tour time are different; the
\textit{bootstrapping }flag is used as an indicator of whether the tour
time has been divided into multiple cycles.

It is desirable to switch off the \textit{multi-cycle} flag as soon as possible;
once switched off, this routine will not be
revisited. This switch is performed here in the case that bootstrapping
was never activated, and in the 
\textref{refactor\_bootstrap}{ref:GJ_controls_refactor_bootstrap} method
otherwise.

If necessary, the \textit{monitor\_bootstrap}
method is called; this
counts the number of cycles performed in this tour, and sets flags to
inform each integrator whether it needs to store its state in its
bootstrap array. When necessary, it calls the
\reftext{refactor\_bootstrap}{ref:GJ_controls_refactor_bootstrap} method.

\subsubsection{refactor\_bootstrap}\label{ref:GJ_controls_refactor_bootstrap}

This method is used to inform each integrator that it needs to
repopulate its history array with its bootstrap array (which comprises
an equal number of data points, but spaced at double the time interval,
thereby covering twice as much time history). If so, the cycle time
step gets doubled. If that takes the cycle time step up to the tour
time step, then the bootstrapping is switched off, and the \textit{multi-cycle}
flag is set to false. This latter step ensures that the
\textit{end\_integration\_cycle}, and thereby the \textit{monitor\_bootstrap}
method, and thereby this method, are not called
again.

\subsubsection{get\_correcting\_primes}\label{ref:GJ_get_correcting_primes}
At the end of the priming process, each integrator will correct its last
RK4-generated priming point to produce a set of priming points consistent
with the Gauss-Jackson integration coefficients.  The process itself is
very analagous to the correction phase of the Gauss-Jackson integration
itself.  Because different integrators may converge their last priming point
in different numbers of iterations, and because the integration cannot proceed
until all of the integrators have converged their last priming point, each
integrator must be informed of whether the other integrators in this group
are still actively correcting.  This method is called by each of the 
integrators, and returns the flag \textit{correcting\_primes}.

Each integrator keeps a record of the number of correction iterations it has
passed through, and sends that value to this method.  This method also
maintains a record of the iteration count on which it last processed.
Only when the incoming iteration count exceeds the stored value is the
\textit{correcting\_primes} flag evaluated.  This is quite reasonable,
since all integrators in the group must see the same value for this flag.  
Hence, the \textit{correcting\_primes} flag should be evaluated when the first 
integrator starts a new iteration round, then held at that setting so that it 
is accessed equally by all 
integrators thereafter.

A related flag, \textit{prime\_point\_still\_to\_correct}, is set by the
integrators when their convergence fails.  Thus, at the start of each
iteration-set, this method queries whether the 
\textit{prime\_point\_still\_to\_correct} flag was set by \textit{any}
integrator in the previous iteration-set.  If so, there is at least one 
integrator still converging, and the \textit{correcting\_primes} flag is set
to true; the \textit{prime\_point\_still\_to\_correct} is also reset to false,
to be triggered again by any failed convergences.  If the last iteration-set 
was passed cleanly, then all integrators can proceed, and the 
\textit{correcting\_primes}
flag is set to \textit{false} accordingly.  Now, all integrators can be 
informed that all integrators have completed their correction process. 


\subsection{Integrator}\label{sec:GJ_Detailed_Design_Integrator}

\subsubsection{integrate}\label{ref:GJ_integrate}
The primary external call is to the
\textit{GaussJacksonTwoStateIntegrator} method, \textit{integrate}.  When returning from this method, control passes back to the integration group, from where this method is called from each integrator in the group, in turn.  The returned boolean value is combined for all integrators; only when all intergators return true does the group indicate that the integration process has been completed.

\begin{enumerate}
\item On the first call to integrate (first time in the simulation, or
first time since being reset for some reason) the following flags are
preset:

 \begin{enumerate}
 \item \textit{primed = false}
 \item \textit{first\_time\_through = true.}

 \end{enumerate}

\item The first task is to assign the input state values to the internal
variables \textit{state}, \textit{state\_dot}, and
\textit{state\_dotdot, }and the integration step size to the internal
variable \textit{cycle\_dyn\_dt.}

\item The first test is for whether the algorithm has been primed --
that is, does it have the requisite number of data points in its
history. For the first call, the answer is always no, indicated by
\textit{primed = false}. If the integrator is primed, the
priming sequence is
skipped over, and the algorithm continues with step \ref{ref:step4}.

\begin{enumerate}
\item The determination of whether the integrator is primed is actually
carried out by the integration controls at the end of the cycle
time-step (see the Controls method
\reftext{end\_integration\_cycle}{ref:GJ_end_integration_cycle} for details),
and is the same for all integrators in this integration group. As this
integration cycle starts, that determination is pulled in to this
integrator (and all other integrators in this group in their turn); if
the integrator controls show that priming was completed last cycle
time-step, the primer can be skipped, and the algorithm continues with
step \ref{ref:step3_2}.  Otherwise:

\begin{enumerate}
\item On the very first call to \textit{integrate}, and after some integrator
resets, the integrator will need initializing. In this case, the
method \reftext{initialize\_integrator}{ref:GJ_initialize_integrator}
is called.

\item Once initialized, the priming point can be generated using the
\reftext{integrate\_primer}{ref:GJ_integrate_primer} method.
The algorithm is complete for this
cycle time-step; \textbf{RETURN TO TOP LEVEL} with a flag indicating
whether the integration was successfully completed (e.g. if the priming
integrator is RK4, this will always return true, since RK4 requires no
internal checking).
\end{enumerate}

\item \label{ref:step3_2}To proceed with the Gauss-Jackson integration,
the history must be
self-consistent with the Gauss-Jackson integration coefficients.
Since that history was generated with RK4, that consistency cannot be
assumed, so the last step in the priming process is to
adjust, or correct, the last data point in
the history (ultimately using the \reftext{correct\_state}{ref:GJ_correct_state}
method, in the same way that the predict-correct-evaluate-correct- ...
method makes corrections to the Gauss-Jackson-generated points).
Note that the Controls \textit{primed} flag indicates only
whether the data points have been generated, whereas the
integrator's \textit{primed} flag indicates whether the data
points have been generated and corrected. The first step in the
correction process, at each iteration, is to increment the counter of
the number of times this integrator has tried to correct that last data
point.

\item Because different integrators in this group may converge at
different iteration-counts, and all integrators in the group must have
converged before proceeding, the integration controls is needed to keep
track of whether there are integrators still correcting this data
point. The Controls method
\textref{get\_correcting\_primes}{ref:GJ_get_correcting_primes}
provides this integrator with the
authority to proceed with correcting its state.  That authority is denied only 
when all integrators have indicated that their state has converged, in which 
case the algorithm
continues with step \ref{ref:step3_4}.  Otherwise:

\begin{enumerate}
\item With authority from the controller, this integrator now queries
whether it actually needs to correct its last point (it may have
converged while other integrators in its group are still converging).
If so, the method 
\textref{correct\_last\_priming\_point}{ref:GJ_correct_last_priming_point}
is called.

\item With the Controls indicating that convergence has not been
universally achieved, the integration target cannot have been achieved,
but nothing more can be done with this integrator. \textbf{RETURN TO
TOP LEVEL} with a flag indicating that the integration has not been
successfully completed.

\end{enumerate}

\item \label{ref:step3_4} The priming phase is actually complete; this
integrator's \textit{primed} flag can be reset
accordingly. The flag indicating whether the bootstrapping algorithm is
active is copied in from the integration controls, and the
\textit{stage\_number} value is set to zero, indicating that the Gauss-Jackson
integration is about to start a cycle time-step with a prediction of
the next state.
\end{enumerate}


\item \label{ref:step4} The code branches here, based on the \textit{stage\_number} value.

\begin{enumerate}
\item \textit{stage\_number = 2} Waiting phase. This integrator has
already completed its cycle time-step, including appropriate
convergence. The \textit{target\_stage }indicates the
\textit{stage\_number} that the integrator is trying to reach. It is
passed into the \textit{integrate} routine as an argument, set by logic
associated with the Integration Controls; it will be reset to \textit{1}
when the Integration Controls indicates that all integrators are
complete.

\begin{enumerate}
\item \textit{target\_stage = 2. }The integrator has nothing to do, it
is already at its target stage and is just waiting for other
integrators in its group to finish. \textbf{RETURN TO TOP LEVEL} with
a flag indicating that the integration for this stage was successfully
completed.
\item \textit{target\_stage = 1. }The Controls has indicated
that all integrators in this group completed their tasks, and has
advanced to the next cycle time-step. The \textit{stage\_number} is reset to
zero, and the algorithm proceeds.
\end{enumerate}

\item \textit{stage\_number = 0} Prediction phase. Call to
\textref{predict\_state}{ref:GJ_predict_state}.
\textbf{RETURN TO TOP LEVEL }with a flag
indicating that the integration for this stage was successfully
completed (prediction phase cannot fail).

\item \textit{stage\_number = 1} Correction -- Evaluation phase.
\ Call to \textref{correct\_state}{ref:GJ_correct_state}.
\textbf{RETURN TO TOP LEVEL} with a flag indicating true if the
correction converged (or ran out of
available iterations), and false if convergence failed and this
integrator must be revisited.
\end{enumerate}
\end{enumerate}


\subsubsection{correct\_last\_priming\_point}
\label{ref:GJ_correct_last_priming_point}

This method is called at the end of the priming sequence after all
priming points have been generated. To proceed with the Gauss-Jackson
integration, the history must be self-consistent with the Gauss-Jackson
integration coefficients. Since that history was generated with RK4,
that consistency cannot be assumed, so the last step in the
priming process is to ``correct'' the last data point in the history.

\begin{enumerate}

\item The value \textit{first\_time\_through} is flagged to \textit{true}
in the reset mechanism and in the constructor. There is no place to
reset it that can be accessed before this point in the algorithm; it
indicates that this is the first pass through this method since the
integrator was last reset. If this flag is true:

\begin{enumerate}
\item Call to \textref{generate\_sum\_arrays}{ref:GJ_generate_sum_arrays}
calculates the
summed array values (see \textref{Appendix A}{sec:summation_term}
for description of
these values) based on the priming points.

\item Call to \textref{reset\_back\_points}{ref:GJ_reset_back_points}
sets the \textit{back\_points} array to its initial configuration.
\end{enumerate}

\item The method \textref{correct\_state}{ref:GJ_correct_state}
is called to perform the state
correction and test for convergence.

\item If convergence has been achieved, or the maximum iteration count
has been exceeded, the integrator's
\textit{correcting\_last\_priming\_point }flag is set to
\textit{false}. Otherwise, the Integration Controls is informed that
this integrator failed to achieve convergence; this tells the
Integration Controls to hold all other integrators in this group until
convergence has been achieved.

\item {\bfseries RETURN TO} \textref{integrate}{ref:GJ_integrate}.
\end{enumerate}

\subsubsection{predict\_state}\label{ref:GJ_predict_state}

This method is called as the first stage in calculating the next state
from the method \textref{integrate}{ref:GJ_integrate}.

\begin{enumerate}

\item The derivative histories need to keep track of the ``now''
derivative of the state before
advancing to the next cycle time-step. It is only during the
prediction phase that the \textit{state\_dot} and
\textit{state\_dotdot} values (recall, these are passed in at the
top-level call, \textit{integrate}) are representative of a stored
state. The call to \textref{record\_deriv}{ref:GJ_record_deriv}
stores off these values in the appropriate places.

\item The ``next'' state is
predicted, following the methods presented in 
\textref{Appendix A: Derivation of Gauss-Jackson 
Algorithm}{app:gj_deriv} (see, in particular, equations~\ref{eq:gj_predictor} 
and~\ref{eq:sa_predictor}).

\item The \textit{stage\_number} is adjusted to \textit{1} to indicate that the
integrator will next go to the correction phase.

\item The \textit{first\_time\_through} flag is set to true, this forces
the integrator through its first-correction section (see
\textref{correct\_state}{ref:GJ_correct_state} for details).
\item {\bfseries RETURN TO} \textref{integrate}{ref:GJ_integrate}.
\end{enumerate}

\subsubsection{correct\_state}\label{ref:GJ_correct_state}

This method is called from the method \textref{integrate}{ref:GJ_integrate}
as the second
and subsequent stages in calculating the next state. It will
be called until the state converges, or until the iteration count
exceeds some threshold value, whichever occurs first.

\begin{enumerate}
\item The assumption is made that the correction is successful (i.e. the
state converges); the \textit{target\_attained} flag is set to \textit{true},
and reset only if the convergence fails.
\item On the first correction following the prediction phase, it is
required that we take some steps that are not necessary on subsequent
corrections.

\begin{enumerate}
\item The iteration count is reset

\item The coefficients used to generate the updated
{\textquotedblleft}next{\textquotedblright} state (i.e. the corrected
state) depend on the derivative histories. Excepting the derivative
of the {\textquotedblleft}next{\textquotedblright} state, which changes
with each correction, that history will be fixed at each iteration, and
the generation of the coefficient contributions from that history can
be made once, and stored for additional corrections.
\end{enumerate}

\item On all correction calls, the state is corrected following the
algorithm presented in \textref{Appendix A: Derivation of Gauss-Jackson 
Algorithm}{app:gj_deriv} (see, in 
particular, equations~\ref{eq:sa_corrector} and~\ref{eq:gj_corrector}).

\item The application of the convergence test, and the threshold to use
in that convergence test are both user-specified. If the convergence
test is required (\textit{perform\_convergence\_test = true}) the
\textit{state\_convergence} method is called, returning a flag to
indicate convergence or not.

\begin{enumerate}
\item  If the test is performed and the state has converged:

\begin{enumerate}
\item The \textit{stage\_number} is set to $2$, to indicate that this
integrator has completed its task, and is waiting for approval from
Integration Controls to proceed to the next cycle time-step.
\end{enumerate}
\item If the test is performed and the state did not converge:

\begin{enumerate}
\item The iteration count is incremented.
\item If the convergence count exceeds its limit
(\textit{max\_corrections\_iterations} in the Controls), a
warning message is sent, and the \textit{stage\_number} is set to $2$,
to indicate that this integrator has completed its task.
\item If the convergence count is still within limits, the
\textit{stage\_number} is held at $1$, and the flag
\ \textit{target\_attained }set to \textit{false}. The correction
will be processed again.
\end{enumerate}

\item If the test is not performed, the correction
automatically succeeds, and the \textit{stage\_number} is set to two,
to indicate that this integrator has completed its task.
\end{enumerate}
\item The output of the integrate method is the state (including zeroth-
and first- derivatives). The corrected values are copied over the
input values (note that the corrected values do not overwrite the input
values at the generation of those corrected values because both sets
are needed for the convergence test).
\item {\bfseries RETURN TO} \textref{integrate}{ref:GJ_integrate}.
\end{enumerate}

\subsubsection{integrate\_primer}\label{ref:GJ_integrate_primer}

Called from \textref{integrate}{ref:GJ_integrate} while the priming points
are being
generated. This uses the priming integrator (RK4) to generate the
first several data points. For a Gauss-Jackson integrator of order
\textit{n}, there must be \textit{n+1} priming points. One half of
these will be pre-epoch points (data from
{\textquotedblleft}before{\textquotedblright} the start of the
integration), and one half will be post-epoch points. In the event of
an odd number, there will be one more post-epoch point than pre-epoch
point. The pre-epoch points are generated first, then the state is
reset to its epoch value, and the post-epoch points are generated.

Following the paradigm we have seen in earlier functions, there is some
overlap in the usage of similarly-named flags found in the integrator class 
and its Controls;
the integrator's value records
where the integrator is, while the Integration Controls value records
where the integrator should be.

During the Gauss-Jackson integration, the stage\_number value can be 0,
1 or 2. During the RK4 integration, it must be between 0 and 4, with
4 indicating that the RK4 integration has reached the end of its cycle
time-step.

\begin{enumerate}
\item If a new cycle time-step is starting (the integrator having
reached \newline \textit{stage\_number = 4}), there are several steps to take

\begin{enumerate}
\item The \textit{prime\_point\_count}, the number of priming points, is
updated from Integration Controls. This value indicates the number of
points away from the epoch, not the total number of points generated.
It resets to zero in Integration Controls after the pre-epoch points are all
generated.
\item If the integrator thinks it is generating priming points in the
reverse direction (\textit{generating\_pre\_epoch\_points}):

\begin{enumerate}
\item The derivative history data will be stored in memory at a location
\textit{prime\_point\_count }preceding the epoch; that location is determined.

\item Outside of the integrator's scope, the Integration Controls
will reset its \textit{prime\_point\_count} to zero and reset its flag 
\textit{generating\_pre\_epoch\_points} upon recognizing that 
sufficient pre-epoch points have been generated. 
As long as the Integration Controls continues to indicate that additional
pre-epoch points are needed, then the algorithm continues to generate
them, continuing at step \ref{ref:int_prim_step1_4}.
If, however, those values have been reset, then in this routine:

\begin{enumerate}
\item Reset the integrator's
\textit{generating\_pre\_epoch\_points }flag.

\item Store the recently calculated derivative values for
{\textquotedblleft}this{\textquotedblright} state in the appropriate
history arrays (note, this is not a duplicate of step 
\ref{ref:int_prim_step1_4};
these derivatives will be overwritten in the next step and lost forever
if not stored right now).

\item Repopulate the state (zeroth-, first-, and second- derivatives)
with the values at the start of the simulation in preparation for going
forwards from the epoch.

\item If these derivative values are needed for the bootstrapping
algorithm, also store the data in the bootstrapping history array with
a call to \textref{record\_for\_bootstrapping}{ref:GJ_record_for_bootstrapping}.
Note - pre-epoch points cannot be used for bootstrapping; this call is intended
to store the epoch values that just repopulated the state values.

\item Continue to step \ref{ref:int_prim_step1_4}
\end{enumerate}
\end{enumerate}
\item After the integrator has been instructed to generate priming
points in the forward direction:

\begin{enumerate}
\item The derivative history data will be stored in memory at a location
\textit{prime\_point\_count }after the epoch; that location is determined.

\item If these derivative values are needed for the bootstrapping
algorithm, also store the data in the bootstrapping history array with
a call to \textref{record\_for\_bootstrapping}{ref:GJ_record_for_bootstrapping}.

\end{enumerate}
\item \label{ref:int_prim_step1_4} For all prime points \textit{except} the epoch,
store the state
derivatives in the appropriate history arrays (the epoch has already
been stored).
\end{enumerate}
\item Using the current full state (zeroth-, first-, and second-
derivatives) call the \textit{integrate} method for the priming
integrator.
\item Update the \textit{stage\_number }accordingly with the integration
stage.
\item {\bfseries RETURN TO} \textref{integrate}{ref:GJ_integrate}.
\end{enumerate}

\subsubsection{allocate\_order\_dependent\_arrays}\label{ref:GJ_allocate_order_dependent_arrays}

This method is called from the integrator constructor, or from
\textref{initialize\_integrator}{ref:GJ_initialize_integrator}.

\begin{enumerate}
\item It assumes that the Integration Controls has already allocated all
of its memory, an absolutely necessary step. If that is not true, the
code will fail. \textbf{FAIL}

\item The order of this integrator is copied in from the Integration
Controls.

\item In the event that the integrator has been reset mid-simulation
(resulting in the call to this method), this integrator may already have
memory allocated. In that case, the \textit{allocated} flag will be
\textit{true.} If the order from the Integration Controls does not
match the previously recorded order, all of the previous allocation is
deleted with a call to \textit{destruct\_order\_dependent\_arrays} and
the \textit{allocated} flag reset to \textit{false.}

\item If the \textit{allocated} flag reads \textit{false,} a number of
variables get memory allocated, and pointers are set to access data in
the Integration Controls class that are common to all integrators in
this group. 
\item {\bfseries RETURN.}
\end{enumerate}


\subsubsection{initialize\_integrator}\label{ref:GJ_initialize_integrator}

Called from \textref{integrate}{ref:GJ_integrate} at the start of a simulation and
following integrator resets.

\begin{enumerate}
\item Call to \textref{allocate\_order\_dependent\_arrays}{ref:GJ_allocate_order_dependent_arrays}
to ensure that
the necessary arrays have been allocated.
\item If the bootstrapping algorithm is active, the number of cycle
time-steps per integration time-step is copied in from Integration
Controls (without bootstrapping, this must be 1).
\item The initial full state (zeroth-, first-, and second- derivatives)
is stored in the appropriate places.
\item Appropriate flags are set.
\item {\bfseries RETURN TO} \textref{integrate}{ref:GJ_integrate}.
\end{enumerate}

\subsubsection{state\_convergence}\label{ref:GJ_state_convergence}

Called from \textref{correct\_state}{ref:GJ_correct_state},
this routine tests whether the
corrections to a state are significant by testing each component
individually. If \textit{any} component has a relative difference
that is larger than some user-specified threshold, the state has not
converged. Note that this is applied to the zeroth derivative of
state only.

\subsubsection{record\_deriv}\label{ref:GJ_record_deriv}

Called from \textref{predict\_state}{ref:GJ_predict_state}, 
this is a catch-all of things that
have to happen when a new cycle time-step starts. The ultimate goal
is to record the first- and second- derivatives generated from the last
recorded state in the derivative history arrays, and the bootstrap
array if necessary.

\begin{enumerate}
\item First, test for bootstrapping. If the integrator is using the
bootstrapping algorithm:

\begin{enumerate}
\item Test whether the number of cycle time-steps per integration
time-step matches that from the Integration Controls. As in other
places, this value is duplicated between the two classes because it is
generated in the Integration Controls, and used in the integrator. If
the two do not match, the bootstrap was re-factored (i.e. the cycle
time-step was doubled) since the last cycle time-step. In this case:

\begin{enumerate}
\item Copy the number of cycle time-steps per integration time-step, and
the bootstrapping flag from that of the Integration Controls.
\item Call \textref{refactor\_bootstrap}{ref:GJ_refactor_bootstrap} to
reconfigure the history and the bootstrap history arrays.
\item Call \textref{reset\_back\_points}{ref:GJ_reset_back_points} in
recognition that the arrays have been reconfigured. This sets the indexing for
the history arrays to their default settings.
\item Call \textref{recalculate\_sum\_arrays}{ref:GJ_recalculate_sum_arrays};
the derivative history
and cycle time-step have both changed, and the summed arrays (see
\textref{Appendix A}{sec:summation_term} for details)
will change accordingly.
\end{enumerate}
\item If the Integration Controls indicate to do so, call
\textref{record\_for\_bootstrapping}{ref:GJ_record_for_bootstrapping}
to make sure that these derivatives get stored in the bootstrap arrays.
\end{enumerate}
\item The \textit{back\_points} array is an index into the history
array; \textit{back\_points[0]} is the location in the history array
where the most recent derivatives are stored, while
\textit{back\_points[order]} gives the location of the oldest values.
\ The oldest value gets overwritten with the input values, and the
\textit{back\_points} array gets shifted one place accordingly.
\item {\bfseries RETURN TO} \textref{predict\_state}{ref:GJ_predict_state}
\end{enumerate}


\subsubsection{record\_for\_bootstrapping}\label{ref:GJ_record_for_bootstrapping}

Called from \textref{integrate\_primer}{ref:GJ_integrate_primer} or 
\textref{record\_deriv}{ref:GJ_record_deriv} when
instructed to do so by the Integration Controls.  Copies the
first- and second- derivatives of the most recent state into the
bootstrap history arrays.

\subsubsection{refactor\_bootstrap}\label{ref:GJ_refactor_bootstrap}

Called from \textref{record\_deriv}{ref:GJ_record_deriv} when the
Integration Controls has
recognized that there are sufficient data points in the bootstrap
history arrays to use them to override the main history arrays.

\begin{enumerate}
\item The bootstrap history arrays are copied over the regular history
arrays
\item If bootstrapping is still active (i.e. the most recent refactor
did not make it redundant), copy every-other value from the bootstrap
arrays back into the same arrays (so element 0 remains, element 2 moves
to element 1, element 4 moves to element 2, etc.)
\item {\bfseries RETURN TO} \textref{integrate}{ref:GJ_record_deriv}.
\end{enumerate}


\subsubsection{recalculate\_sum\_arrays}\label{ref:GJ_recalculate_sum_arrays}

Called from \textref{record\_deriv}{ref:GJ_record_deriv} when the Integration
Controls has
recognized that there are sufficient data points in the bootstrap
history arrays to use them to override the main history arrays. The
effect is that the cycle time-step doubles (since the time interval
between the history elements doubles), and the history is completely
rewritten. Since the summed arrays depend on the derivative history
and cycle time-step the summed arrays must be recalculated. See
\textref{Appendix A}{app:gj_deriv}
for details of how the cycle time-step affects the evaluation of the
various coefficients.


\subsubsection{generate\_sum\_arrays}\label{ref:GJ_generate_sum_arrays}

Called from 
\textref{correct\_last\_priming\_point}{ref:GJ_correct_last_priming_point}
only on the first
pass. This method will only be called once per simulation, unless the
integrator gets reset mid-simulation with a new order.
This method makes the first calculation
of the summed arrays after priming is completed. For details of the arrays, see
\textref{Appendix A}{sec:summation_term}, where they are labeled as $\alpha_n$ 
and~$g\gamma_n$.


\subsubsection{reset}\label{ref:GJ_reset}

Can be called from outside. Simply resets the necessary flags to
delete the history and force re-initialization.

\subsubsection{reset\_back\_points}\label{ref:GJ_reset_back_points}

Called from \textref{record\_deriv}{ref:GJ_record_deriv} and 
\textref{correct\_last\_priming\_point}{ref:GJ_correct_last_priming_point},
both of which set the history arrays so that the oldest data is at
element \textit{0}, working forward to \textit{order-1}. Temporarily,
the location of the oldest value is set to be \textit{order}, where
there may be no data at all; the rationale is that at the start of the
next cycle time-step, the new derivative values will override the
oldest in the list. By setting the oldest data location to the
``wrong'' place, we assure that when
the new data is added, we have the full \textit{order+1} data elements,
from oldest at element \textit{0} to newest at element \textit{order}.


