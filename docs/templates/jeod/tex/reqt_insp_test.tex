\section{Requirements, Inspections, and Tests}
\label{sec:reqt_insp_test}
One of the key strengths of the JEOD project is the rigor of its
verification and validation process.
This section describes the macros that authors must use in their
model document |.tex| files to specify the requirements of the model,
the inspections of the model against the requirements, and the
software tests that demonstrate that the model satisfies the requirements
levied against it.

\subsection{Requirements}\label{sec:reqt}
The |\requirement| macro is used in the Requirements chapter of a model document
to introduce a new requirement. The macro takes one argument, the name of the
requirement. After introducing a requirement, give it a label and then describe
the requirement in a description block with a very specific form.
For example,
\begin{codeblock}
\requirement{Handling of Incoming Events}
\label{reqt:unique_label}
\begin{description}
\item[Requirement:]\ \\
  The model shall do this, that, and the other upon receipt of an event.
\item[Rationale:]\ \\
  This is cool, that is needed, and the other is just awesome.
\item[Verification:]\ \\
  Inspection, test
\end{description}
\end{codeblock}
The above generates the following:
\def\ModelPrefix{Example}
\requirement{Handling of Incoming Events}
\label{reqt:unique_label}
\begin{description}
\item[Requirement:]\ \\
  The model shall do this, that, and the other upon receipt of an event.
\item[Rationale:]\ \\
  This is cool, that is needed, and the other is just awesome.
\item[Verification:]\ \\
  Inspection, test
\end{description}

The requirement can be cross-referenced using the |\label| given to the
requirement. For example, |requirement~\ref{reqt:unique_label}| yields
requirement~\ref{reqt:unique_label}. The requirements can be inserted in
the table of contents if desired (see section~\ref{sec:add_to_toc}).

One problem with the way in which requirement~\ref{reqt:unique_label} was
written is that the use of the description environment forces the document 
author to write description item labels in a peculiar way.
The author needs to ensure item labels end with a colon and
needs to add that |\ \\| construct after the label to force a newline.
The \dynenv package provides a colon form of the description environment,
|description:|, to automatically perform both of these tasks:
\begin{codeblock}
\requirement{Handling of Incoming Events}
\label{reqt:another_label}
\begin{description:}
\item[Requirement]
  The model shall do this, that, and the other upon receipt of an event.
\item[Rationale]
  This is cool, that is needed, and the other is just awesome.
\item[Verification]
  Inspection, test
\end{description:}
\end{codeblock}
Except for the auto-incremented requirement number, the output generated by
the above is identical to that of requirement~\ref{reqt:unique_label}:
\def\ModelPrefix{Example}
\requirement{Handling of Incoming Events}
\label{reqt:another_label}
\begin{description:}
\item[Requirement]
  The model shall do this, that, and the other upon receipt of an event.
\item[Rationale]
  This is cool, that is needed, and the other is just awesome.
\item[Verification]
  Inspection, test
\end{description:}

There is a bigger problem with this requirement. It is a good example
of a bad requirement.
The problem is that the requirement specifies three distinct things.
One alternative is to split this poorly written requirement into three separate
requirements. Another is to use the \command{subrequirement} macro:
\begin{codeblock}
\requirement[Event Handling]{Handling of Incoming Events}
\label{reqt:yet_another_label}
\begin{description:}
\item[Requirement]
 Upon receipt of an event,
 \subrequirement{This.}\label{reqt:yet_another_label_this}
 The model shall do this.
 \subrequirement{That.}\label{reqt:yet_another_label_that}
 The model shall do that.
 \subrequirement{Other.}\label{reqt:yet_another_label_other}
 The model shall do the other.
\item[Rationale]
  This is cool, that is needed, and the other is just awesome.
\item[Verification]
  Inspection, test
\end{description:}
\end{codeblock}

\def\ModelPrefix{Example}
\requirement[Event Handling]{Handling of Incoming Events}
\label{reqt:yet_another_label}
\begin{description:}
\item[Requirement]
 Upon receipt of an event,
 \subrequirement{This.}\label{reqt:yet_another_label_this}
 The model shall do this.
 \subrequirement{That.}\label{reqt:yet_another_label_that}
 The model shall do that.
 \subrequirement{Other.}\label{reqt:yet_another_label_other}
 The model shall do the other.
\item[Rationale]
  This is cool, that is needed, and the other is just awesome.
\item[Verification]
  Inspection, test
\end{description:}


\subsection{Inspections}\label{sec:inspections}
The |\inspection| macro is used in the Inspections section of the Inspections,
Tests, and Metrics chapter of a model document to introduce a new inspection.
An ``inspection'' of a product somehow verifies without using the product that
the product satisfies some of the requirements levied on it.
Examples include peer reviews,
a desk check comparison of the mathematics as implemented in the code against
the mathematical description in the model document, and a desk check comparison
of the model interfaces versus some external specification.

The |\inspection| macro takes one argument, the name of the inspection.
After introducing an inspection, give it a label via the |\label| macro and then
describe the inspection in some way. This description can vary in form.
The JEOD project has not prescribed a rigid form for these inspections.
The inspection must indicate the application requirements and must indicate
whether the model passed or failed the inspection.

\begin{codeblock}
\inspection{Event Processing Inspection}
\label{inspect:events}
The model processes events via the method \verb#EventHandler::process_event#.
This function in turn calls three methods to process the incoming event:
\begin{itemize}
\item \verb#EventHandler::do_this#, which does this.
\item \verb#EventHandler::do_that#, which does that.
\item \verb#EventHandler::do_the_other_thing#, which does the other thing.
\end{itemize}
By inspection, the model satisfies
requirement~\traceref{reqt:yet_another_label}.
\end{codeblock}
The above generates the following:
\inspection{Event Processing Inspection}
\label{inspect:events}
The model processes events via the method \verb#EventHandler::process_event#.
This function in turn calls three methods to process the incoming event:
\begin{itemize}
\item \verb#EventHandler::do_this#, which does this.
\item \verb#EventHandler::do_that#, which does that.
\item \verb#EventHandler::do_the_other_thing#, which does the other thing.
\end{itemize}
By inspection, the model satisfies
requirement~\traceref{reqt:yet_another_label}.

\subsection{Tests}\label{sec:tests}
The |\test| macro is used in the Tests section of the Inspections,
Tests, and Metrics chapter of a model document to introduce a new inspection.
A ``test'' of a product uses the product in some way to demonstrate that the
product satisfies some of the requirements levied on it.
Some tests involve simulations while others involve unit tests.
The test should exercise the model in a manner
that allows the output to be compared against some expected result.

The |\test| macro takes one argument, the name of the test.
inspection. After introducing a test, give it a label and then describe
the test in some way. As with inspections, this description can vary.
A widely used approach is to use a description environment. Typical labels are:
\begin{description}
\item[Background] Provides background information regarding the test.
\item[Test description] Provides details on what was done.
\item[Test directory] Specifies where the test code resides.
\item[Success criteria] Specifies how the test is deemed to be successful.
\item[Test results] Describes the results of running the test.
\item[Applicable requirements] Identifies the requirement(s) tested.
\end{description}

\subsection{Specifying Applicable Requirements}
Words


\subsection{Traceability}
Each inspection and test should trace to one or more requirements, and each
requirement should be verified/validated by one or more inspection or test.
Every model document is supposed to contain a requirements
traceability table\footnote{
  The requirements traceability table is typically located in the
  ``Requirements Traceability'' section of the ``Inspections, Tests, and
  Metrics'' chapter of a model document.} %
that lists the mapping from requirements to inspections and tests.
 

\subsection[Adding Requirements etc. to the TOC]
{Adding Requirements, Inspections, and Tests to the Table of Contents}
\label{sec:add_to_toc}
The \command{dynenvaddtotoc} and \command{dynenvaddtocitems} macros
provide the ability to make the requirements, inspections, and tests
specified in document listed in that document's table of contents.

Words
